"use strict";(globalThis.webpackChunkweb=globalThis.webpackChunkweb||[]).push([[8496],{3722:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>t,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"simulation/gazebo-physics","title":"01. Gazebo Physics","description":"Simulating Real-World Dynamics and Sensors","source":"@site/docs/simulation/gazebo-physics.md","sourceDirName":"simulation","slug":"/simulation/gazebo-physics","permalink":"/physical-ai-book/docs/simulation/gazebo-physics","draft":false,"unlisted":false,"editUrl":"https://github.com/AnasMehmood0/physical-ai-book/tree/main/web/docs/simulation/gazebo-physics.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"sidebar_label":"01. Gazebo Physics"},"sidebar":"tutorialSidebar","previous":{"title":"02. Python Code","permalink":"/physical-ai-book/docs/ros2/python-code"},"next":{"title":"02. Unity HRI","permalink":"/physical-ai-book/docs/simulation/unity-hri"}}');var r=i(4848),l=i(8453);const o={sidebar_position:1,sidebar_label:"01. Gazebo Physics"},a="01. Gazebo Physics",t={},c=[{value:"Simulating Real-World Dynamics and Sensors",id:"simulating-real-world-dynamics-and-sensors",level:2},{value:"Introduction to Gazebo",id:"introduction-to-gazebo",level:2},{value:"Why Use Gazebo?",id:"why-use-gazebo",level:3},{value:"Gazebo Architecture",id:"gazebo-architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Physics Engines",id:"physics-engines",level:2},{value:"ODE (Open Dynamics Engine)",id:"ode-open-dynamics-engine",level:3},{value:"Bullet",id:"bullet",level:3},{value:"Simbody",id:"simbody",level:3},{value:"DART (Dynamic Animation and Robotics Toolkit)",id:"dart-dynamic-animation-and-robotics-toolkit",level:3},{value:"Choosing a Physics Engine",id:"choosing-a-physics-engine",level:3},{value:"World and Model Description: SDF and URDF",id:"world-and-model-description-sdf-and-urdf",level:2},{value:"SDF (Simulation Description Format)",id:"sdf-simulation-description-format",level:3},{value:"URDF (Unified Robot Description Format)",id:"urdf-unified-robot-description-format",level:3},{value:"Key Differences: SDF vs URDF",id:"key-differences-sdf-vs-urdf",level:3},{value:"Physics Simulation",id:"physics-simulation",level:2},{value:"Gravity",id:"gravity",level:3},{value:"Friction and Surface Properties",id:"friction-and-surface-properties",level:3},{value:"Inertia and Mass Properties",id:"inertia-and-mass-properties",level:3},{value:"Collision Detection",id:"collision-detection",level:3},{value:"Joint Types and Constraints",id:"joint-types-and-constraints",level:3},{value:"Sensor Simulation",id:"sensor-simulation",level:2},{value:"Camera Sensors",id:"camera-sensors",level:3},{value:"LiDAR Sensors",id:"lidar-sensors",level:3},{value:"IMU Sensors",id:"imu-sensors",level:3},{value:"Force/Torque Sensors",id:"forcetorque-sensors",level:3},{value:"GPS Sensors",id:"gps-sensors",level:3},{value:"ROS 2 and Gazebo Integration",id:"ros-2-and-gazebo-integration",level:2},{value:"Gazebo Classic with ROS 2",id:"gazebo-classic-with-ros-2",level:3},{value:"Launching Gazebo with ROS 2",id:"launching-gazebo-with-ros-2",level:3},{value:"Spawning Robots Programmatically",id:"spawning-robots-programmatically",level:3},{value:"Gazebo Plugins for ROS 2",id:"gazebo-plugins-for-ros-2",level:3},{value:"Controlling Robot from ROS 2",id:"controlling-robot-from-ros-2",level:3},{value:"Best Practices and Performance Optimization",id:"best-practices-and-performance-optimization",level:2},{value:"Simulation Fidelity vs. Speed",id:"simulation-fidelity-vs-speed",level:3},{value:"Model Optimization",id:"model-optimization",level:3},{value:"Parallel Simulation",id:"parallel-simulation",level:3},{value:"Headless Simulation",id:"headless-simulation",level:3},{value:"Debugging Physics Issues",id:"debugging-physics-issues",level:3},{value:"Common Issues and Solutions",id:"common-issues-and-solutions",level:2},{value:"Issue 1: Robot Falls Through Ground",id:"issue-1-robot-falls-through-ground",level:3},{value:"Issue 2: Unstable Simulation",id:"issue-2-unstable-simulation",level:3},{value:"Issue 3: Slow Simulation",id:"issue-3-slow-simulation",level:3},{value:"Issue 4: Inaccurate Sensor Data",id:"issue-4-inaccurate-sensor-data",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"01-gazebo-physics",children:"01. Gazebo Physics"})}),"\n",(0,r.jsx)(e.h2,{id:"simulating-real-world-dynamics-and-sensors",children:"Simulating Real-World Dynamics and Sensors"}),"\n",(0,r.jsx)(e.p,{children:"This chapter explores the use of Gazebo, a powerful 3D robot simulator, for accurately modeling real-world physics and sensor interactions. It covers fundamental concepts of physics engines within simulation, including rigid body dynamics, collision detection, and joint constraints. The chapter will detail how to configure and integrate various sensor models (e.g., cameras, LiDAR, IMUs) within Gazebo to mimic their real-world counterparts, providing realistic data streams for AI development. Emphasis will be placed on understanding the nuances of simulation accuracy, performance optimization, and the critical role of high-fidelity physics in training robust robotic systems."}),"\n",(0,r.jsx)(e.h2,{id:"introduction-to-gazebo",children:"Introduction to Gazebo"}),"\n",(0,r.jsx)(e.p,{children:"Gazebo (formerly known as Gazebo Classic, with the newer version called Ignition Gazebo or Gazebo Sim) is an open-source 3D robotics simulator that provides accurate physics simulation, high-quality graphics rendering, and sensor simulation. It's tightly integrated with the Robot Operating System (ROS and ROS 2), making it the de facto standard for robotics research and development."}),"\n",(0,r.jsx)(e.h3,{id:"why-use-gazebo",children:"Why Use Gazebo?"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Advantages:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Cost-Effective"}),": Test algorithms without risking expensive hardware"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Safety"}),": Experiment with potentially dangerous behaviors in simulation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Reproducibility"}),": Controlled environments enable repeatable experiments"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Scalability"}),": Run multiple parallel simulations for training"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Rapid Iteration"}),": Faster development cycles than physical prototyping"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"ROS Integration"}),": Native support for ROS topics, services, and plugins"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Common Use Cases:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Algorithm development and testing"}),"\n",(0,r.jsx)(e.li,{children:"Robot design validation"}),"\n",(0,r.jsx)(e.li,{children:"Multi-robot coordination"}),"\n",(0,r.jsx)(e.li,{children:"Reinforcement learning training"}),"\n",(0,r.jsx)(e.li,{children:"Hardware-in-the-loop testing"}),"\n",(0,r.jsx)(e.li,{children:"Education and demonstrations"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"gazebo-architecture",children:"Gazebo Architecture"}),"\n",(0,r.jsx)(e.h3,{id:"core-components",children:"Core Components"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Gazebo Server (gzserver)        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Physics  \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502   Sensors    \u2502  \u2502\n\u2502  \u2502  Engine   \u2502        \u2502              \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502         \u25b2                     \u25b2         \u2502\n\u2502         \u2502                     \u2502         \u2502\n\u2502         \u25bc                     \u25bc         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502   World   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502   Plugins    \u2502  \u2502\n\u2502  \u2502   State   \u2502        \u2502              \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u25b2\n                   \u2502 Network/IPC\n                   \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Gazebo Client (gzclient)           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Rendering\u2502        \u2502  GUI/User    \u2502  \u2502\n\u2502  \u2502  Engine   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502  Interface   \u2502  \u2502\n\u2502  \u2502  (OGRE)   \u2502        \u2502              \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"gzserver"}),": Headless simulation server"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Physics computation"}),"\n",(0,r.jsx)(e.li,{children:"Sensor data generation"}),"\n",(0,r.jsx)(e.li,{children:"Plugin execution"}),"\n",(0,r.jsx)(e.li,{children:"World state management"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"gzclient"}),": GUI visualization client"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"3D rendering"}),"\n",(0,r.jsx)(e.li,{children:"User interaction"}),"\n",(0,r.jsx)(e.li,{children:"Camera views"}),"\n",(0,r.jsx)(e.li,{children:"Model manipulation"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"This client-server architecture allows running simulations on powerful compute servers while visualizing on separate machines, or running headless for batch training."}),"\n",(0,r.jsx)(e.h2,{id:"physics-engines",children:"Physics Engines"}),"\n",(0,r.jsx)(e.p,{children:"Gazebo supports multiple physics engines, each with different characteristics and trade-offs."}),"\n",(0,r.jsx)(e.h3,{id:"ode-open-dynamics-engine",children:"ODE (Open Dynamics Engine)"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Characteristics:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Default physics engine in Gazebo Classic"}),"\n",(0,r.jsx)(e.li,{children:"Stable and well-tested"}),"\n",(0,r.jsx)(e.li,{children:"Good general-purpose performance"}),"\n",(0,r.jsx)(e.li,{children:"Supports various constraint types"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Strengths:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Mature codebase with extensive use"}),"\n",(0,r.jsx)(e.li,{children:"Handles complex contact scenarios"}),"\n",(0,r.jsx)(e.li,{children:"Good for rigid body dynamics"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Limitations:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Can be computationally expensive for complex scenes"}),"\n",(0,r.jsx)(e.li,{children:"Less accurate than modern alternatives for certain scenarios"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"bullet",children:"Bullet"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Characteristics:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Used extensively in gaming and VFX"}),"\n",(0,r.jsx)(e.li,{children:"Fast collision detection"}),"\n",(0,r.jsx)(e.li,{children:"Good multi-threading support"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Strengths:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Excellent performance for large numbers of objects"}),"\n",(0,r.jsx)(e.li,{children:"Robust collision handling"}),"\n",(0,r.jsx)(e.li,{children:"Well-optimized"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Limitations:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Sometimes less stable for complex constraints"}),"\n",(0,r.jsx)(e.li,{children:"Tuning parameters can be tricky"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"simbody",children:"Simbody"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Characteristics:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Focus on biomechanics and accurate dynamics"}),"\n",(0,r.jsx)(e.li,{children:"High-quality contact modeling"}),"\n",(0,r.jsx)(e.li,{children:"Used in scientific simulations"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Strengths:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Very accurate for complex kinematic chains"}),"\n",(0,r.jsx)(e.li,{children:"Excellent for human/animal locomotion"}),"\n",(0,r.jsx)(e.li,{children:"Sophisticated constraint handling"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Limitations:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Slower than ODE or Bullet"}),"\n",(0,r.jsx)(e.li,{children:"Higher computational requirements"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"dart-dynamic-animation-and-robotics-toolkit",children:"DART (Dynamic Animation and Robotics Toolkit)"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Characteristics:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Modern physics engine"}),"\n",(0,r.jsx)(e.li,{children:"Analytical gradients for optimization"}),"\n",(0,r.jsx)(e.li,{children:"Focus on robotics applications"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Strengths:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Excellent for trajectory optimization"}),"\n",(0,r.jsx)(e.li,{children:"Differentiable physics"}),"\n",(0,r.jsx)(e.li,{children:"Good performance"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"choosing-a-physics-engine",children:"Choosing a Physics Engine"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- In world file (.world) --\x3e\n<world name="default">\n  <physics type="ode">\n    <max_step_size>0.001</max_step_size>\n    <real_time_factor>1.0</real_time_factor>\n    <real_time_update_rate>1000</real_time_update_rate>\n  </physics>\n  \x3c!-- Or use: type="bullet", "simbody", "dart" --\x3e\n</world>\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Decision Factors:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Speed vs. Accuracy"}),": ODE/Bullet for speed, Simbody for accuracy"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Contact Complexity"}),": Bullet for many contacts, Simbody for precise contacts"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Optimization Needs"}),": DART if you need gradients"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Stability"}),": ODE is most battle-tested"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"world-and-model-description-sdf-and-urdf",children:"World and Model Description: SDF and URDF"}),"\n",(0,r.jsx)(e.h3,{id:"sdf-simulation-description-format",children:"SDF (Simulation Description Format)"}),"\n",(0,r.jsx)(e.p,{children:"SDF is Gazebo's native XML format for describing robots, environments, sensors, and physics."}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Example World File:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<sdf version="1.6">\n  <world name="robot_world">\n    \x3c!-- Physics configuration --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <gravity>0 0 -9.81</gravity>\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <light name="sun" type="directional">\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>1 1 1 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <direction>0 0 -1</direction>\n    </light>\n\n    \x3c!-- Ground plane --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>100</mu>\n                <mu2>50</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.8 0.8 0.8 1</ambient>\n          </material>\n        </visual>\n      </link>\n    </model>\n  </world>\n</sdf>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"urdf-unified-robot-description-format",children:"URDF (Unified Robot Description Format)"}),"\n",(0,r.jsx)(e.p,{children:"URDF, originating from ROS, describes robot kinematics and dynamics. Gazebo can convert URDF to SDF."}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Example Robot URDF:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_robot">\n  \x3c!-- Base link --\x3e\n  <link name="base_link">\n    <inertial>\n      <mass value="10.0"/>\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0"\n               iyy="0.1" iyz="0.0" izz="0.1"/>\n    </inertial>\n    <visual>\n      <geometry>\n        <box size="0.5 0.3 0.2"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 0.8 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.5 0.3 0.2"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Wheel link --\x3e\n  <link name="left_wheel">\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0"\n               iyy="0.01" iyz="0.0" izz="0.01"/>\n    </inertial>\n    <visual>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder radius="0.1" length="0.05"/>\n      </geometry>\n    </collision>\n  </link>\n\n  \x3c!-- Joint --\x3e\n  <joint name="left_wheel_joint" type="continuous">\n    <parent link="base_link"/>\n    <child link="left_wheel"/>\n    <origin xyz="-0.15 0.2 -0.1" rpy="1.57 0 0"/>\n    <axis xyz="0 0 1"/>\n  </joint>\n</robot>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"key-differences-sdf-vs-urdf",children:"Key Differences: SDF vs URDF"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Feature"}),(0,r.jsx)(e.th,{children:"URDF"}),(0,r.jsx)(e.th,{children:"SDF"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Origin"})}),(0,r.jsx)(e.td,{children:"ROS"}),(0,r.jsx)(e.td,{children:"Gazebo"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Scope"})}),(0,r.jsx)(e.td,{children:"Single robot"}),(0,r.jsx)(e.td,{children:"Entire world"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Sensors"})}),(0,r.jsx)(e.td,{children:"Limited"}),(0,r.jsx)(e.td,{children:"Comprehensive"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Physics"})}),(0,r.jsx)(e.td,{children:"Basic"}),(0,r.jsx)(e.td,{children:"Advanced"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Closed loops"})}),(0,r.jsx)(e.td,{children:"No"}),(0,r.jsx)(e.td,{children:"Yes"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Versioning"})}),(0,r.jsx)(e.td,{children:"No"}),(0,r.jsx)(e.td,{children:"Yes"})]})]})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Recommendation"}),": Use URDF for robot description (ROS compatibility), SDF for world files and when you need advanced features."]}),"\n",(0,r.jsx)(e.h2,{id:"physics-simulation",children:"Physics Simulation"}),"\n",(0,r.jsx)(e.h3,{id:"gravity",children:"Gravity"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<physics type="ode">\n  <gravity>0 0 -9.81</gravity> \x3c!-- Earth gravity --\x3e\n  \x3c!-- <gravity>0 0 -1.62</gravity> --\x3e \x3c!-- Moon gravity --\x3e\n  \x3c!-- <gravity>0 0 -3.71</gravity> --\x3e \x3c!-- Mars gravity --\x3e\n</physics>\n'})}),"\n",(0,r.jsx)(e.p,{children:"Adjusting gravity is useful for:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Testing robustness under different planetary conditions"}),"\n",(0,r.jsx)(e.li,{children:"Simplifying dynamics for learning (lower gravity = slower falls)"}),"\n",(0,r.jsx)(e.li,{children:"Stress-testing control algorithms"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"friction-and-surface-properties",children:"Friction and Surface Properties"}),"\n",(0,r.jsx)(e.p,{children:"Friction is critical for realistic wheel-ground interaction, grasping, and contact dynamics."}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Coulomb Friction Model:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:"<surface>\n  <friction>\n    <ode>\n      <mu>1.0</mu>      \x3c!-- Friction coefficient (direction 1) --\x3e\n      <mu2>1.0</mu2>    \x3c!-- Friction coefficient (direction 2) --\x3e\n      <slip1>0.0</slip1>\n      <slip2>0.0</slip2>\n    </ode>\n  </friction>\n  <contact>\n    <ode>\n      <kp>1000000.0</kp>  \x3c!-- Contact stiffness --\x3e\n      <kd>100.0</kd>      \x3c!-- Contact damping --\x3e\n      <max_vel>0.01</max_vel>\n      <min_depth>0.001</min_depth>\n    </ode>\n  </contact>\n</surface>\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Friction Coefficients:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Rubber on concrete: \u03bc \u2248 1.0"}),"\n",(0,r.jsx)(e.li,{children:"Metal on metal: \u03bc \u2248 0.15-0.25"}),"\n",(0,r.jsx)(e.li,{children:"Ice on ice: \u03bc \u2248 0.02"}),"\n",(0,r.jsx)(e.li,{children:"Teflon on Teflon: \u03bc \u2248 0.04"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"inertia-and-mass-properties",children:"Inertia and Mass Properties"}),"\n",(0,r.jsx)(e.p,{children:"Accurate inertia is crucial for realistic dynamics."}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Computing Inertia:"})}),"\n",(0,r.jsx)(e.p,{children:"For simple shapes:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Box"}),": ",(0,r.jsx)(e.code,{children:"Ixx = (m/12)(h\xb2 + d\xb2)"}),", ",(0,r.jsx)(e.code,{children:"Iyy = (m/12)(w\xb2 + d\xb2)"}),", ",(0,r.jsx)(e.code,{children:"Izz = (m/12)(w\xb2 + h\xb2)"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Cylinder"}),": ",(0,r.jsx)(e.code,{children:"Ixx = Iyy = (m/12)(3r\xb2 + h\xb2)"}),", ",(0,r.jsx)(e.code,{children:"Izz = (m/2)r\xb2"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sphere"}),": ",(0,r.jsx)(e.code,{children:"Ixx = Iyy = Izz = (2/5)mr\xb2"})]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"For complex meshes, use CAD software to compute inertia tensors."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<inertial>\n  <mass value="5.0"/>\n  <origin xyz="0 0 0" rpy="0 0 0"/>\n  <inertia ixx="0.083" ixy="0.0" ixz="0.0"\n           iyy="0.083" iyz="0.0" izz="0.083"/>\n</inertial>\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Common Mistakes:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Zero or very small mass/inertia (causes instability)"}),"\n",(0,r.jsx)(e.li,{children:"Incorrect inertia tensor (non-physical behavior)"}),"\n",(0,r.jsx)(e.li,{children:"Center of mass misalignment"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"collision-detection",children:"Collision Detection"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Collision Geometries:"})}),"\n",(0,r.jsx)(e.p,{children:"Use simplified collision meshes for performance:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<collision name="collision">\n  <geometry>\n    \x3c!-- Simple primitive (fast) --\x3e\n    <box size="1 1 1"/>\n    \x3c!-- Or mesh (slower but accurate) --\x3e\n    \x3c!-- <mesh><uri>model://robot/meshes/collision.stl</uri></mesh> --\x3e\n  </geometry>\n</collision>\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Best Practices:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Use primitives (box, sphere, cylinder) when possible"}),"\n",(0,r.jsx)(e.li,{children:"Decompose complex shapes into convex hulls"}),"\n",(0,r.jsx)(e.li,{children:"Separate visual and collision meshes"}),"\n",(0,r.jsx)(e.li,{children:"Avoid deeply nested geometries"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"joint-types-and-constraints",children:"Joint Types and Constraints"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Joint Types:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Revolute: rotation with limits --\x3e\n<joint name="joint1" type="revolute">\n  <parent link="link1"/>\n  <child link="link2"/>\n  <axis xyz="0 0 1"/>\n  <limit lower="-1.57" upper="1.57" effort="10" velocity="1.0"/>\n</joint>\n\n\x3c!-- Continuous: unlimited rotation --\x3e\n<joint name="wheel_joint" type="continuous">\n  <parent link="chassis"/>\n  <child link="wheel"/>\n  <axis xyz="0 1 0"/>\n</joint>\n\n\x3c!-- Prismatic: linear motion --\x3e\n<joint name="slider" type="prismatic">\n  <parent link="base"/>\n  <child link="slider"/>\n  <axis xyz="1 0 0"/>\n  <limit lower="0" upper="1.0" effort="100" velocity="0.5"/>\n</joint>\n\n\x3c!-- Fixed: rigid connection --\x3e\n<joint name="camera_joint" type="fixed">\n  <parent link="base"/>\n  <child link="camera"/>\n</joint>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,r.jsx)(e.h3,{id:"camera-sensors",children:"Camera Sensors"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"RGB Camera:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="camera" type="camera">\n  <camera>\n    <horizontal_fov>1.047</horizontal_fov> \x3c!-- 60 degrees --\x3e\n    <image>\n      <width>640</width>\n      <height>480</height>\n      <format>R8G8B8</format>\n    </image>\n    <clip>\n      <near>0.1</near>\n      <far>100</far>\n    </clip>\n    <noise>\n      <type>gaussian</type>\n      <mean>0.0</mean>\n      <stddev>0.007</stddev>\n    </noise>\n  </camera>\n  <update_rate>30</update_rate>\n</sensor>\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Depth Camera:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="depth_camera" type="depth">\n  <camera>\n    <horizontal_fov>1.047</horizontal_fov>\n    <image>\n      <width>640</width>\n      <height>480</height>\n    </image>\n    <clip>\n      <near>0.1</near>\n      <far>10.0</far>\n    </clip>\n  </camera>\n  <update_rate>30</update_rate>\n</sensor>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"lidar-sensors",children:"LiDAR Sensors"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"2D LiDAR (Laser Scanner):"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="laser" type="ray">\n  <ray>\n    <scan>\n      <horizontal>\n        <samples>720</samples>\n        <resolution>1</resolution>\n        <min_angle>-1.57</min_angle> \x3c!-- -90 degrees --\x3e\n        <max_angle>1.57</max_angle>  \x3c!-- +90 degrees --\x3e\n      </horizontal>\n    </scan>\n    <range>\n      <min>0.10</min>\n      <max>30.0</max>\n      <resolution>0.01</resolution>\n    </range>\n    <noise>\n      <type>gaussian</type>\n      <mean>0.0</mean>\n      <stddev>0.01</stddev>\n    </noise>\n  </ray>\n  <update_rate>40</update_rate>\n</sensor>\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"3D LiDAR:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="velodyne" type="ray">\n  <ray>\n    <scan>\n      <horizontal>\n        <samples>1875</samples>\n        <resolution>1</resolution>\n        <min_angle>-3.14159</min_angle>\n        <max_angle>3.14159</max_angle>\n      </horizontal>\n      <vertical>\n        <samples>16</samples>\n        <resolution>1</resolution>\n        <min_angle>-0.2618</min_angle> \x3c!-- -15 degrees --\x3e\n        <max_angle>0.2618</max_angle>  \x3c!-- +15 degrees --\x3e\n      </vertical>\n    </scan>\n    <range>\n      <min>0.9</min>\n      <max>130.0</max>\n      <resolution>0.001</resolution>\n    </range>\n  </ray>\n  <update_rate>10</update_rate>\n</sensor>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"imu-sensors",children:"IMU Sensors"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="imu" type="imu">\n  <imu>\n    <angular_velocity>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.009</stddev>\n        </noise>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.009</stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.009</stddev>\n        </noise>\n      </z>\n    </angular_velocity>\n    <linear_acceleration>\n      <x>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.017</stddev>\n        </noise>\n      </x>\n      <y>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.017</stddev>\n        </noise>\n      </y>\n      <z>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>0.017</stddev>\n        </noise>\n      </z>\n    </linear_acceleration>\n  </imu>\n  <update_rate>100</update_rate>\n</sensor>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"forcetorque-sensors",children:"Force/Torque Sensors"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="force_torque" type="force_torque">\n  <force_torque>\n    <frame>child</frame>\n    <measure_direction>child_to_parent</measure_direction>\n  </force_torque>\n  <update_rate>100</update_rate>\n</sensor>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"gps-sensors",children:"GPS Sensors"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="gps" type="gps">\n  <gps>\n    <position_sensing>\n      <horizontal>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>2.0</stddev> \x3c!-- meters --\x3e\n        </noise>\n      </horizontal>\n      <vertical>\n        <noise type="gaussian">\n          <mean>0.0</mean>\n          <stddev>4.0</stddev>\n        </noise>\n      </vertical>\n    </position_sensing>\n  </gps>\n  <update_rate>4</update_rate>\n</sensor>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"ros-2-and-gazebo-integration",children:"ROS 2 and Gazebo Integration"}),"\n",(0,r.jsx)(e.h3,{id:"gazebo-classic-with-ros-2",children:"Gazebo Classic with ROS 2"}),"\n",(0,r.jsx)(e.p,{children:"Install required packages:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# ROS 2 Humble + Gazebo 11\nsudo apt install ros-humble-gazebo-ros-pkgs ros-humble-gazebo-ros\n"})}),"\n",(0,r.jsx)(e.h3,{id:"launching-gazebo-with-ros-2",children:"Launching Gazebo with ROS 2"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Launch File Example:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# gazebo_world.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import ExecuteProcess, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch_ros.actions import Node\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    pkg_gazebo_ros = get_package_share_directory('gazebo_ros')\n\n    # Gazebo server\n    gzserver_cmd = ExecuteProcess(\n        cmd=['gzserver', '-s', 'libgazebo_ros_factory.so',\n             '--verbose', 'worlds/my_world.world'],\n        output='screen'\n    )\n\n    # Gazebo client\n    gzclient_cmd = ExecuteProcess(\n        cmd=['gzclient'],\n        output='screen'\n    )\n\n    return LaunchDescription([\n        gzserver_cmd,\n        gzclient_cmd\n    ])\n"})}),"\n",(0,r.jsx)(e.h3,{id:"spawning-robots-programmatically",children:"Spawning Robots Programmatically"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Python Script:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom gazebo_msgs.srv import SpawnEntity\nimport os\n\nclass RobotSpawner(Node):\n    def __init__(self):\n        super().__init__('robot_spawner')\n        self.spawn_client = self.create_client(SpawnEntity, '/spawn_entity')\n\n        while not self.spawn_client.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Waiting for spawn_entity service...')\n\n        self.spawn_robot()\n\n    def spawn_robot(self):\n        # Read robot description from file\n        urdf_path = os.path.join(\n            os.path.expanduser('~'),\n            'robot_ws/src/my_robot/urdf/robot.urdf'\n        )\n\n        with open(urdf_path, 'r') as f:\n            robot_desc = f.read()\n\n        # Create spawn request\n        request = SpawnEntity.Request()\n        request.name = 'my_robot'\n        request.xml = robot_desc\n        request.robot_namespace = 'robot1'\n        request.initial_pose.position.x = 0.0\n        request.initial_pose.position.y = 0.0\n        request.initial_pose.position.z = 0.5\n\n        # Call service\n        future = self.spawn_client.call_async(request)\n        rclpy.spin_until_future_complete(self, future)\n\n        if future.result() is not None:\n            self.get_logger().info(f'Successfully spawned {request.name}')\n        else:\n            self.get_logger().error('Failed to spawn robot')\n\ndef main():\n    rclpy.init()\n    spawner = RobotSpawner()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(e.h3,{id:"gazebo-plugins-for-ros-2",children:"Gazebo Plugins for ROS 2"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Differential Drive Plugin (in URDF/SDF):"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<gazebo>\n  <plugin name="differential_drive_controller" filename="libgazebo_ros_diff_drive.so">\n    <update_rate>50</update_rate>\n    <left_joint>left_wheel_joint</left_joint>\n    <right_joint>right_wheel_joint</right_joint>\n    <wheel_separation>0.4</wheel_separation>\n    <wheel_diameter>0.2</wheel_diameter>\n    <max_wheel_torque>20</max_wheel_torque>\n    <command_topic>cmd_vel</command_topic>\n    <odometry_topic>odom</odometry_topic>\n    <odometry_frame>odom</odometry_frame>\n    <robot_base_frame>base_link</robot_base_frame>\n    <publish_odom>true</publish_odom>\n    <publish_odom_tf>true</publish_odom_tf>\n    <publish_wheel_tf>false</publish_wheel_tf>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Camera Plugin:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="camera_link">\n  <sensor type="camera" name="camera1">\n    <update_rate>30.0</update_rate>\n    <camera name="head">\n      <horizontal_fov>1.3962634</horizontal_fov>\n      <image>\n        <width>800</width>\n        <height>800</height>\n        <format>R8G8B8</format>\n      </image>\n      <clip>\n        <near>0.02</near>\n        <far>300</far>\n      </clip>\n    </camera>\n    <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\n      <frame_name>camera_link</frame_name>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"controlling-robot-from-ros-2",children:"Controlling Robot from ROS 2"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\n\nclass RobotController(Node):\n    def __init__(self):\n        super().__init__('robot_controller')\n        self.publisher = self.create_publisher(Twist, '/cmd_vel', 10)\n        self.timer = self.create_timer(0.1, self.move_robot)\n        self.count = 0\n\n    def move_robot(self):\n        msg = Twist()\n\n        # Move in a circle\n        msg.linear.x = 0.5  # Forward velocity (m/s)\n        msg.angular.z = 0.5  # Angular velocity (rad/s)\n\n        self.publisher.publish(msg)\n        self.count += 1\n\n        if self.count > 100:  # Stop after 10 seconds\n            msg.linear.x = 0.0\n            msg.angular.z = 0.0\n            self.publisher.publish(msg)\n            self.get_logger().info('Stopping robot')\n            raise SystemExit\n\ndef main():\n    rclpy.init()\n    controller = RobotController()\n    rclpy.spin(controller)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(e.h2,{id:"best-practices-and-performance-optimization",children:"Best Practices and Performance Optimization"}),"\n",(0,r.jsx)(e.h3,{id:"simulation-fidelity-vs-speed",children:"Simulation Fidelity vs. Speed"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Trade-offs:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Higher physics update rate \u2192 More accurate but slower"}),"\n",(0,r.jsx)(e.li,{children:"Complex collision meshes \u2192 Realistic but computationally expensive"}),"\n",(0,r.jsx)(e.li,{children:"Sensor noise models \u2192 Better sim-to-real but adds overhead"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Recommendations:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- For real-time interactive simulation --\x3e\n<physics type="ode">\n  <max_step_size>0.001</max_step_size>\n  <real_time_update_rate>1000</real_time_update_rate>\n  <real_time_factor>1.0</real_time_factor>\n</physics>\n\n\x3c!-- For faster-than-real-time training --\x3e\n<physics type="bullet">\n  <max_step_size>0.01</max_step_size>\n  <real_time_update_rate>100</real_time_update_rate>\n  <real_time_factor>0</real_time_factor> \x3c!-- Run as fast as possible --\x3e\n</physics>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"model-optimization",children:"Model Optimization"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"1. Simplify Collision Geometry:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Bad: High-poly mesh --\x3e\n<collision>\n  <geometry>\n    <mesh><uri>detailed_model.dae</uri></mesh>\n  </geometry>\n</collision>\n\n\x3c!-- Good: Primitive approximation --\x3e\n<collision>\n  <geometry>\n    <box size="1 0.5 0.3"/>\n  </geometry>\n</collision>\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"2. Reduce Sensor Update Rates:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Cameras: 10-30 Hz (not 60+)"}),"\n",(0,r.jsx)(e.li,{children:"LiDAR: 10-20 Hz"}),"\n",(0,r.jsx)(e.li,{children:"IMU: 100-200 Hz (not 1000+)"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"3. Disable Unnecessary Features:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:"<visual>\n  <cast_shadows>false</cast_shadows> \x3c!-- Disable shadows for better performance --\x3e\n</visual>\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"4. Use Level of Detail (LOD):"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:"<visual>\n  <geometry>\n    <mesh>\n      <uri>model://robot/meshes/visual.dae</uri>\n    </mesh>\n  </geometry>\n</visual>\n"})}),"\n",(0,r.jsx)(e.h3,{id:"parallel-simulation",children:"Parallel Simulation"}),"\n",(0,r.jsx)(e.p,{children:"For RL training, run multiple Gazebo instances:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# Terminal 1\nGAZEBO_MASTER_URI=http://localhost:11345 gzserver world1.world\n\n# Terminal 2\nGAZEBO_MASTER_URI=http://localhost:11346 gzserver world2.world\n\n# Terminal 3\nGAZEBO_MASTER_URI=http://localhost:11347 gzserver world3.world\n"})}),"\n",(0,r.jsx)(e.p,{children:"Or use Docker containers for isolation."}),"\n",(0,r.jsx)(e.h3,{id:"headless-simulation",children:"Headless Simulation"}),"\n",(0,r.jsx)(e.p,{children:"For batch processing and training:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# No GUI\ngzserver --verbose world.world\n\n# Or in launch file\ngzserver_cmd = ExecuteProcess(\n    cmd=['gzserver', '--verbose', '-s', 'libgazebo_ros_factory.so',\n         'my_world.world'],\n    output='screen'\n)\n"})}),"\n",(0,r.jsx)(e.h3,{id:"debugging-physics-issues",children:"Debugging Physics Issues"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Enable Visualization:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# View contact points\ngzclient --verbose\n# In GUI: View \u2192 Contacts\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Check Physics Parameters:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport rclpy\nfrom gazebo_msgs.srv import GetModelState\n\n# Query model state for debugging\ndef check_model_state(model_name):\n    rclpy.init()\n    node = rclpy.create_node(\'state_checker\')\n    client = node.create_client(GetModelState, \'/gazebo/get_model_state\')\n\n    request = GetModelState.Request()\n    request.model_name = model_name\n\n    future = client.call_async(request)\n    rclpy.spin_until_future_complete(node, future)\n\n    if future.result():\n        state = future.result()\n        print(f"Position: {state.pose.position}")\n        print(f"Orientation: {state.pose.orientation}")\n        print(f"Linear velocity: {state.twist.linear}")\n        print(f"Angular velocity: {state.twist.angular}")\n'})}),"\n",(0,r.jsx)(e.h2,{id:"common-issues-and-solutions",children:"Common Issues and Solutions"}),"\n",(0,r.jsx)(e.h3,{id:"issue-1-robot-falls-through-ground",children:"Issue 1: Robot Falls Through Ground"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Cause"}),": Collision geometry not properly defined or very small mass\n",(0,r.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Ensure ground has collision --\x3e\n<collision name="ground_collision">\n  <geometry>\n    <plane><normal>0 0 1</normal></plane>\n  </geometry>\n</collision>\n\n\x3c!-- Ensure robot has reasonable mass --\x3e\n<inertial>\n  <mass value="1.0"/> \x3c!-- Not 0.001 --\x3e\n</inertial>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"issue-2-unstable-simulation",children:"Issue 2: Unstable Simulation"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Cause"}),": Time step too large or contact parameters incorrect\n",(0,r.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:"<physics>\n  <max_step_size>0.001</max_step_size> \x3c!-- Smaller step --\x3e\n  <ode>\n    <solver>\n      <iters>50</iters> \x3c!-- Increase solver iterations --\x3e\n    </solver>\n    <constraints>\n      <cfm>0.0</cfm>\n      <erp>0.2</erp>\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\n      <contact_surface_layer>0.001</contact_surface_layer>\n    </constraints>\n  </ode>\n</physics>\n"})}),"\n",(0,r.jsx)(e.h3,{id:"issue-3-slow-simulation",children:"Issue 3: Slow Simulation"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Causes"}),": Too many contacts, complex meshes, high update rates\n",(0,r.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Simplify collision meshes"}),"\n",(0,r.jsx)(e.li,{children:"Reduce sensor update rates"}),"\n",(0,r.jsx)(e.li,{children:"Switch to faster physics engine (Bullet)"}),"\n",(0,r.jsx)(e.li,{children:"Disable GUI (headless mode)"}),"\n",(0,r.jsx)(e.li,{children:"Reduce real-time factor"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"issue-4-inaccurate-sensor-data",children:"Issue 4: Inaccurate Sensor Data"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Cause"}),": Missing noise models or incorrect sensor placement\n",(0,r.jsx)(e.strong,{children:"Solution"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:"<sensor>\n  <noise>\n    <type>gaussian</type>\n    <mean>0.0</mean>\n    <stddev>0.01</stddev> \x3c!-- Add realistic noise --\x3e\n  </noise>\n</sensor>\n"})}),"\n",(0,r.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Gazebo provides high-fidelity physics simulation essential for robotics development"}),"\n",(0,r.jsx)(e.li,{children:"Multiple physics engines (ODE, Bullet, Simbody, DART) offer different trade-offs"}),"\n",(0,r.jsx)(e.li,{children:"SDF is Gazebo's native format; URDF is ROS-compatible and convertible"}),"\n",(0,r.jsx)(e.li,{children:"Accurate physics requires proper mass, inertia, friction, and contact parameters"}),"\n",(0,r.jsx)(e.li,{children:"Sensor simulation includes cameras, LiDAR, IMU, GPS, force/torque sensors"}),"\n",(0,r.jsx)(e.li,{children:"ROS 2 integration enables seamless testing of ROS-based control systems"}),"\n",(0,r.jsx)(e.li,{children:"Performance optimization involves balancing fidelity with computational cost"}),"\n",(0,r.jsx)(e.li,{children:"Headless and parallel simulations accelerate training for learning-based systems"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Official Documentation"}),": ",(0,r.jsx)(e.a,{href:"http://gazebosim.org/tutorials",children:"Gazebo Tutorials"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"ROS 2 Integration"}),": ",(0,r.jsx)(e.a,{href:"https://github.com/ros-simulation/gazebo_ros_pkgs",children:"gazebo_ros_pkgs Documentation"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"SDF Specification"}),": ",(0,r.jsx)(e.a,{href:"http://sdformat.org/spec",children:"SDFormat Specification"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Physics Engines"}),":","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://www.ode.org/",children:"ODE Documentation"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://pybullet.org/",children:"Bullet Physics"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://dartsim.github.io/",children:"DART"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Books"}),":","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:'"Mastering ROS for Robotics Programming" by Lentin Joseph'}),"\n",(0,r.jsx)(e.li,{children:'"Robot Operating System (ROS): The Complete Reference" Volume 6 (Simulation chapter)'}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Research Papers"}),":","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:'Koenig, N., & Howard, A. (2004). "Design and use paradigms for Gazebo, an open-source multi-robot simulator"'}),"\n"]}),"\n"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>a});var s=i(6540);const r={},l=s.createContext(r);function o(n){const e=s.useContext(l);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),s.createElement(l.Provider,{value:e},n.children)}}}]);